<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Daily Content</title>

    <!-- Favicon block: wide browser support -->
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="manifest" href="site.webmanifest">

    <!-- iOS PWA meta -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Daily Content">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%; /* Ensure html and body take full viewport height */
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f8f9fa;
            color: #333;
            line-height: 1.6;
            overflow: hidden; /* Prevent scrolling if content overflows */
            /* iOS safe area support */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100%; /* Take full height of body (minus safe areas) */
            max-width: 500px;
            margin: 0 auto;
            padding: 20px; /* Default padding for larger screens */
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-top: 20px;
        }
        
        .header h1 {
            font-size: 1.8rem;
            font-weight: 300;
            color: #555;
            margin-bottom: 10px;
        }
        
        .date {
            font-size: 0.9rem;
            color: #888;
            font-weight: 300;
        }
        
        .content-container {
            flex: 1; /* Allows it to take available vertical space */
            display: flex;
            align-items: center; /* Vertically center */
            justify-content: center; /* Horizontally center */
            position: relative;
            overflow: hidden; /* For transition effects */
        }
        
        .content-card {
            background: white;
            border-radius: 16px;
            padding: 40px 30px; /* Default padding */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            width: 100%;
            max-width: 400px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.25s ease-out, opacity 0.25s ease-out; /* Snappier animation */
            user-select: none;
            position: relative;
            min-height: 300px; /* Default min-height */
            display: flex;
            flex-direction: column;
            justify-content: center;
            /* Default state */
            transform: translateX(0);
            opacity: 1;
        }
        
        .content-card:hover {
            transform: translateY(-2px);
        }
        
        /* Animation classes for directional sliding */
        .content-card.slide-out-left {
            transform: translateX(-100%);
            opacity: 0;
        }
        
        .content-card.slide-out-right {
            transform: translateX(100%);
            opacity: 0;
        }
        
        .content-card.slide-in-left {
            transform: translateX(-100%); /* Start off-screen left */
            opacity: 0;
        }
        
        .content-card.slide-in-right {
            transform: translateX(100%); /* Start off-screen right */
            opacity: 0;
        }
        
        /* This class is applied after content update and then removed to trigger entry animation */
        .content-card.active-transition { 
             transform: translateX(0); /* Target state for new card */
             opacity: 1;
        }

        .content-type {
            font-size: 0.8rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .content-title {
            font-size: 1.4rem;
            color: #333;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .content-body {
            font-size: 1rem;
            color: #555;
            line-height: 1.7;
            margin-bottom: 20px;
        }
        
        .content-meta {
            font-size: 0.9rem;
            color: #888;
            font-style: italic;
        }
        
        .swipe-hint {
            text-align: center;
            font-size: 0.75rem;
            color: #aaa;
            opacity: 0.7;
            margin-top: 10px; 
            margin-bottom: 10px; 
        }

        .navigation {
            display: flex;
            justify-content: center;
            margin-top: 15px; 
            gap: 10px;
            z-index: 10; 
            position: relative; 
        }
        
        .nav-dot {
            width: 16px; 
            height: 16px; 
            border-radius: 50%;
            background-color: #bbb;
            border: 2px solid #ccc; 
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, border-color 0.3s ease;
        }
        
        .nav-dot.active {
            background-color: #007AFF;
            border-color: #007AFF;
            transform: scale(1.15);
        }
        
        .nav-dot:hover:not(.active) {
            background-color: #999;
            border-color: #aaa;
        }
        
        .loading {
            color: #888;
            font-size: 0.9rem;
        }
        
        .error {
            color: #ff6b6b;
            font-size: 0.9rem;
        }
        
        @media (max-width: 480px) { /* Styles specifically for iPhone screens */
            .container {
                padding: 10px; 
            }
            
            .content-card {
                max-width: 300px; 
                padding: 20px 15px; 
                min-height: 180px; 
                margin-top: -30px; /* Move card up from center */
            }
            
            .header h1 {
                font-size: 1.3rem;
                margin-bottom: 5px;
            }
            
            .date {
                font-size: 0.8rem;
            }
            
            .content-type {
                font-size: 0.75rem;
                margin-bottom: 15px;
            }
            
            .content-title {
                font-size: 1.0rem; 
                margin-bottom: 15px;
            }
            
            .content-body {
                font-size: 0.85rem; 
                line-height: 1.5;
                margin-bottom: 15px;
            }
            
            .content-meta {
                font-size: 0.8rem;
            }

            .swipe-hint {
                font-size: 0.65rem; 
                margin-top: auto; 
                margin-bottom: 5px;
            }

            .navigation {
                margin-top: 5px; 
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Daily Content</h1>
            <div class="date" id="current-date"></div>
        </div>
        
        <div class="content-container">
            <div class="content-card" id="content-card">
                <div class="content-type" id="content-type">Loading...</div>
                <div class="content-title" id="content-title"></div>
                <div class="content-body" id="content-body">Getting your daily content...</div>
                <div class="content-meta" id="content-meta"></div>
            </div>
        </div>
        
        <div class="swipe-hint">Tap or swipe to navigate</div>

        <div class="navigation">
            </div>
        
    </div>

    <script>
        class DailyContentApp {
            constructor() {
                this.currentIndex = 0;
                this.contentTypes = [
                    { type: 'word', title: 'Word of the Day' },
                    { type: 'history', title: 'Historical Fact' },
                    { type: 'random', title: 'Random Fact' },
                    { type: 'quote', title: 'Quote of the Day' }
                ];
                this.contentData = {};
                this.isLoading = false;
                this.touchStartX = 0;
                this.touchEndX = 0;
                this.isSwiping = false; 
                
                // Hardcoded word list for daily rotation
                this.wordList = [
                    'serendipity', 'ephemeral', 'petrichor', 'luminous', 'mellifluous',
                    'ethereal', 'tranquil', 'vivacious', 'ubiquitous', 'cacophony'
                ];
                
                this.init();
            }
            
            // Get today's date as a string for localStorage key
            getTodayKey() {
                const today = new Date();
                return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            }
            
            // Check if we have cached data for today
            loadCachedData() {
                const todayKey = this.getTodayKey();
                const cachedData = localStorage.getItem(`dailyContent_${todayKey}`);
                
                if (cachedData) {
                    try {
                        this.contentData = JSON.parse(cachedData);
                        // Validate content types exist in cached data for current app version
                        for (const typeDef of this.contentTypes) {
                            if (!this.contentData[typeDef.type]) {
                                console.warn(`Cached data missing content for type: ${typeDef.type}. Refetching all.`);
                                return false; 
                            }
                        }
                        return true;
                    } catch (error) {
                        console.error('Error parsing cached data:', error);
                        localStorage.removeItem(`dailyContent_${todayKey}`); 
                    }
                }
                return false;
            }
            
            // Save today's content to localStorage
            saveCachedData() {
                const todayKey = this.getTodayKey();
                try {
                    localStorage.setItem(`dailyContent_${todayKey}`, JSON.stringify(this.contentData));
                    this.cleanupOldCache();
                } catch (error) {
                    console.error('Error saving cached data:', error);
                }
            }
            
            // Remove cached data from previous days
            cleanupOldCache() {
                const todayKey = this.getTodayKey();
                const keysToRemove = [];
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('dailyContent_') && key !== `dailyContent_${todayKey}`) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => localStorage.removeItem(key));
            }
            
            init() {
                this.updateDate();
                this.setupEventListeners();
                this.updateNavigation(); 
                
                if (this.loadCachedData()) {
                    console.log('Loaded cached data for today');
                    this.displayContent('initial'); // Display without animation on initial load
                } else {
                    console.log('No cached data found, fetching fresh content');
                    this.loadAllContent().then(() => {
                        this.saveCachedData(); 
                        this.displayContent('initial'); // Display without animation on initial load
                    });
                }
            }
            
            updateDate() {
                const now = new Date();
                const options = { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                };
                document.getElementById('current-date').textContent = now.toLocaleDateString('en-US', options);
            }
            
            setupEventListeners() {
                const card = document.getElementById('content-card');
                const dotsContainer = document.querySelector('.navigation'); 
                
                document.body.addEventListener('click', (e) => {
                    if (this.isLoading || this.isSwiping) {
                        this.isSwiping = false; 
                        return;
                    }
                    if (e.target.closest('.nav-dot')) {
                        return;
                    }
                    this.nextContent();
                });
                
                dotsContainer.addEventListener('click', (e) => {
                    const dot = e.target.closest('.nav-dot');
                    if (dot && dot.dataset.index) {
                        this.goToContent(parseInt(dot.dataset.index));
                    }
                });
                
                card.addEventListener('touchstart', (e) => {
                    this.touchStartX = e.changedTouches[0].screenX;
                    this.isSwiping = false; 
                }, { passive: true });
                
                card.addEventListener('touchend', (e) => {
                    this.touchEndX = e.changedTouches[0].screenX;
                    if (this.handleSwipe()) { 
                        this.isSwiping = true; 
                    }
                }, { passive: true });
            }
            
            handleSwipe() {
                const swipeThreshold = 50; 
                const diff = this.touchStartX - this.touchEndX;
                
                if (Math.abs(diff) > swipeThreshold) {
                    if (diff > 0) { // Swiped left (show next)
                        this.nextContent();
                    } else { // Swiped right (show previous)
                        this.prevContent();
                    }
                    return true; 
                }
                return false; 
            }
            
            nextContent() {
                if (this.isLoading) return;
                const newIndex = (this.currentIndex + 1) % this.contentTypes.length;
                this.goToContent(newIndex, 'forward');
            }
            
            prevContent() {
                if (this.isLoading) return;
                const newIndex = (this.currentIndex - 1 + this.contentTypes.length) % this.contentTypes.length;
                this.goToContent(newIndex, 'backward');
            }
            
            goToContent(index, direction = 'forward') {
                if (this.isLoading || index === this.currentIndex) return;
                
                const prevIndex = this.currentIndex;
                this.currentIndex = index;
                this.updateNavigation();
                
                // Determine direction for animation more precisely for dot clicks
                if (direction === 'forward' && index < prevIndex) { // E.g., if clicking from last dot to first
                    direction = 'forward';
                } else if (direction === 'backward' && index > prevIndex) { // E.g., if clicking from first dot to last
                    direction = 'backward';
                } else if (index > prevIndex) { // Normal forward movement
                    direction = 'forward';
                } else if (index < prevIndex) { // Normal backward movement
                    direction = 'backward';
                }

                this.displayContent(direction);
            }
            
            updateNavigation() {
                const navContainer = document.querySelector('.navigation');
                navContainer.innerHTML = ''; 
                this.contentTypes.forEach((_, index) => {
                    const dot = document.createElement('div');
                    dot.classList.add('nav-dot');
                    dot.dataset.index = index;
                    navContainer.appendChild(dot);
                });
                
                const dots = document.querySelectorAll('.nav-dot');
                dots.forEach((dot, index) => {
                    dot.classList.toggle('active', index === this.currentIndex);
                });
            }
            
            async loadAllContent() {
                this.isLoading = true;
                try {
                    await Promise.all([
                        this.fetchWordOfTheDay(),
                        this.fetchHistoricalFact(),
                        this.fetchRandomFact(),
                        this.fetchQuoteOfTheDay()
                    ]);
                } catch (error) {
                    console.error('Error loading content:', error);
                    this.showError('Failed to load content. Please try again later.');
                } finally {
                    this.isLoading = false;
                }
            }
            
            async fetchWordOfTheDay() {
                try {
                    const dayIndex = new Date().getDay(); 
                    const word = this.wordList[dayIndex % this.wordList.length]; 
                    
                    const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                    const data = await response.json();
                    
                    if (data && data[0]) {
                        const entry = data[0];
                        const meaning = entry.meanings[0];
                        const definition = meaning.definitions[0];
                        
                        this.contentData.word = {
                            word: word,
                            definition: definition.definition,
                            example: definition.example || `"${word}" is a beautiful word.`
                        };
                    } else {
                        throw new Error("No definition found for word.");
                    }
                } catch (error) {
                    console.error('Error fetching word:', error);
                    this.contentData.word = {
                        word: 'serendipity',
                        definition: 'The occurrence and development of events by chance in a happy or beneficial way.',
                        example: 'A fortunate stroke of serendipity brought them together.'
                    };
                }
            }
            
            async fetchHistoricalFact() {
                try {
                    const now = new Date();
                    const month = String(now.getMonth() + 1).padStart(2, '0');
                    const day = String(now.getDate()).padStart(2, '0');
                    
                    const response = await fetch(`https://api.wikimedia.org/feed/v1/wikipedia/en/onthisday/all/${month}/${day}`);
                    const data = await response.json();
                    
                    if (data && data.events && data.events.length > 0) {
                        const event = data.events[0];
                        // Format the full date for display
                        const fullDateOptions = { month: 'long', day: 'numeric', year: 'numeric' };
                        // Create a date object with the event year, and current month/day to format correctly.
                        const eventDate = new Date(event.year, now.getMonth(), now.getDate()).toLocaleDateString('en-US', fullDateOptions);

                        this.contentData.history = {
                            fullDate: eventDate, // New field for full date
                            year: event.year,
                            event: event.text,
                            description: event.pages && event.pages[0] ? event.pages[0].extract : ''
                        };
                    } else {
                         throw new Error("No historical events found for today.");
                    }
                } catch (error) {
                    console.error('Error fetching historical fact:', error);
                    const now = new Date(); 
                    const fallbackFacts = [ // Example fallbacks for July 15th
                        { year: '1099', event: 'The Crusaders captured Jerusalem, ending the First Crusade.', description: 'A pivotal moment in medieval history.' },
                        { year: '1799', event: 'The Rosetta Stone was found by French soldiers in Rosetta (Rashid), Egypt.', description: 'Key to deciphering Egyptian hieroglyphs.' },
                        { year: '1965', event: 'Mariner 4 transmits the first close-up pictures of Mars.', description: 'The first successful flyby of Mars by a spacecraft.' }
                    ];
                    const factIndex = now.getDate() % fallbackFacts.length; 
                    const fallbackData = fallbackFacts[factIndex];
                    const fullDateOptions = { month: 'long', day: 'numeric', year: 'numeric' };
                    const fallbackDate = new Date(fallbackData.year, now.getMonth(), now.getDate()).toLocaleDateString('en-US', fullDateOptions);

                    this.contentData.history = {
                        fullDate: fallbackDate, // New field for full date in fallback
                        year: fallbackData.year,
                        event: fallbackData.event,
                        description: fallbackData.description
                    };
                }
            }
            
            async fetchRandomFact() {
                try {
                    const response = await fetch('https://uselessfacts.jsph.pl/random.json?language=en');
                    const data = await response.json();
                    
                    if (data && data.text) {
                        this.contentData.random = {
                            fact: data.text,
                            source: data.source_url || ''
                        };
                    } else {
                        throw new Error("No random fact found.");
                    }
                } catch (error) {
                    console.error('Error fetching random fact:', error);
                    this.contentData.random = {
                        fact: 'Honey never spoils. Archaeologists have found pots of honey in ancient Egyptian tombs that are over 3000 years old and still perfectly edible.',
                        source: ''
                    };
                }
            }
            
            async fetchQuoteOfTheDay() {
                try {
                    const response = await fetch('https://zenquotes.io/api/today');
                    const data = await response.json();
                    
                    if (data && data[0]) {
                        this.contentData.quote = {
                            text: data[0].q,
                            author: data[0].a
                        };
                    } else {
                        throw new Error("No quote found.");
                    }
                } catch (error) {
                    console.error('Error fetching quote:', error);
                    this.contentData.quote = {
                        text: 'The only way to do great work is to love what you do.',
                        author: 'Steve Jobs'
                    };
                }
            }
            
            displayContent(direction = 'forward') { 
                const contentType = this.contentTypes[this.currentIndex];
                const data = this.contentData[contentType.type];
                const card = document.getElementById('content-card');
            
                if (!data) {
                    this.showError('Content not available. Please try refreshing.');
                    return;
                }
            
                // Step 1: Animate the current card out
                if (direction !== 'initial') { // Skip animation on first load
                    card.classList.remove('active-transition'); 
                    if (direction === 'forward') {
                        card.classList.add('slide-out-left');
                    } else {
                        card.classList.add('slide-out-right');
                    }
                }
            
                // Step 2: Update content after a short delay (for exit animation to start)
                const updateDelay = (direction === 'initial') ? 0 : 200; // Shorter delay for snappier feel
            
                setTimeout(() => {
                    // Reset card position and opacity before updating content
                    card.classList.remove('slide-out-left', 'slide-out-right', 'slide-in-left', 'slide-in-right');
                    
                    document.getElementById('content-type').textContent = contentType.title;
                    
                    switch (contentType.type) {
                        case 'word':
                            document.getElementById('content-title').textContent = data.word.toUpperCase();
                            document.getElementById('content-body').textContent = data.definition;
                            document.getElementById('content-meta').textContent = data.example;
                            break;
                            
                        case 'history':
                            document.getElementById('content-title').textContent = data.fullDate; // Use fullDate
                            document.getElementById('content-body').textContent = data.event;
                            document.getElementById('content-meta').textContent = data.description;
                            break;
                            
                        case 'random':
                            document.getElementById('content-title').textContent = 'Did You Know?';
                            document.getElementById('content-body').textContent = data.fact;
                            document.getElementById('content-meta').textContent = ''; 
                            break;
                            
                        case 'quote':
                            document.getElementById('content-title').textContent = '"' + data.text + '"';
                            document.getElementById('content-body').textContent = ''; 
                            document.getElementById('content-meta').textContent = '— ' + data.author;
                            break;
                    }
            
                    // Step 3: Animate the new content in
                    if (direction !== 'initial') {
                        if (direction === 'forward') {
                            card.classList.add('slide-in-right');
                        } else {
                            card.classList.add('slide-in-left');
                        }
                        // Trigger reflow to ensure the 'slide-in' class is applied before the 'active-transition' takes effect
                        card.offsetWidth; 
                        card.classList.add('active-transition'); // Trigger transition to final position
                        setTimeout(() => {
                            // Clean up after animation
                            card.classList.remove('slide-in-left', 'slide-in-right');
                        }, 250); // Match CSS transition duration
                    } else {
                         // For initial load, ensure it's in default state
                         card.classList.add('active-transition');
                    }
                }, updateDelay);
            }
            
            showError(message) {
                document.getElementById('content-type').textContent = 'Error';
                document.getElementById('content-title').textContent = '';
                document.getElementById('content-body').innerHTML = `<span class=\"error\">${message}</span>`;
                document.getElementById('content-meta').textContent = '';
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            new DailyContentApp();
        });
    </script>
</body>
</html>
